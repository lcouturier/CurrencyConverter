<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace CurrencyConverter.Core
{
    using System;
    using System.Diagnostics.CodeAnalysis;
    using System.Diagnostics.Contracts;
    using System.Diagnostics;
	using System.CodeDom.Compiler;

	/// <summary>
    ///     Calcul du temps d'execution d'une méthode
    /// </summary>
    /// <typeparam name="T1">Type en entrée</typeparam>
    /// <typeparam name="TResult">Type en sortie</typeparam>
    /// <param name="func">Fonction évaluée</param>
    /// <returns>
    ///     Nouvelle fonction qui retourne un <see cref="Tuple{T1,T2}" />
    ///     qui contient la valeur de retour de la fonction et le temps d'execution
    /// </returns>
    /// <example>
    ///     calcul de factorielle avec memoization de la fonction et ajout d'un calcul de temps d'execution
    ///     <code>
    /// <![CDATA[
    ///    Func<int, int> factorial = null;
    ///    factorial = x => x.Match().With(i => i < 2, i => i).Else((i => i * factorial(i - 1))).Do();
    ///    var f = factorial.Memoize().Measure();
    /// ]]>
    /// </code>
    /// </example>
    /// <exception cref="Exception">A delegate callback throws an exception.</exception>
	[GeneratedCode("T4CodeGenerator", "1.0.0.0")] 
    public static class FunctionMeasureTransformExtensions
    {	
	    /// <summary>
        ///     Calcul du temps d'execution d'une méthode
        /// </summary>
        /// <typeparam name="T1">Type en entrée</typeparam>
        /// <typeparam name="TResult">Type en sortie</typeparam>
        /// <param name="func">Fonction évaluée</param>
        /// <returns>
        ///     Nouvelle fonction qui retourne un <see cref="Tuple{T1,T2}" />
        ///     qui contient la valeur de retour de la fonction et le temps d'execution
        /// </returns>
        /// <example>
        ///     calcul de factorielle avec memoization de la fonction et ajout d'un calcul de temps d'execution
        ///     <code>
        /// <![CDATA[
        ///    Func<int, int> factorial = null;
        ///    factorial = x => x.Match().With(i => i < 2, i => i).Else((i => i * factorial(i - 1))).Do();
        ///    var f = factorial.Memoize().Measure();
        /// ]]>
        /// </code>
        /// </example>
        /// <exception cref="Exception">A delegate callback throws an exception.</exception>
		[Obsolete("Ne plus utiliser",false)]
        [SuppressMessage("Microsoft.Reliability", "CA2000:Supprimer les objets avant la mise hors de portée")] 
        [SuppressMessage("Microsoft.Design", "CA1006:DoNotNestGenericTypesInMemberSignatures")]
		[SuppressMessage("Microsoft.Design", "CA1062:Valider les arguments de méthodes publiques", Justification = "Géré par Code Contract")]
        public static Func<T1, Tuple<TResult, long>> Measure<T1, TResult>(this Func<T1, TResult> func)
        {
            Contract.Requires<ArgumentNullException>(func != null);
            Contract.Ensures(Contract.Result<Func<T1, Tuple<TResult, long>>>() != null);

            return args =>
            {
                TResult result = default(TResult);
                var sw = new Stopwatch();
                new UnitOfWork(sw.Stop).Do(x =>
                    {
                        sw.Start();
                        result = func(args);
                    });

                return Tuple.Create(result, sw.ElapsedTicks);
            };
        }

		/// <summary>
        ///     Calcul du temps d'execution d'une méthode
        /// </summary>
        /// <typeparam name="T1">Type en entrée</typeparam>
        /// <typeparam name="TResult">Type en sortie</typeparam>
        /// <param name="func">Fonction évaluée</param>
        /// <returns>
        ///     Nouvelle fonction qui retourne un <see cref="Tuple{T1,T2}" />
        ///     qui contient la valeur de retour de la fonction et le temps d'execution
        /// </returns>
        /// <example>
        ///     calcul de factorielle avec memoization de la fonction et ajout d'un calcul de temps d'execution
        ///     <code>
        /// <![CDATA[
        ///    Func<int, int> factorial = null;
        ///    factorial = x => x.Match().With(i => i < 2, i => i).Else((i => i * factorial(i - 1))).Do();
        ///    var f = factorial.Memoize().Measure();
        /// ]]>
        /// </code>
        /// </example>
        /// <exception cref="Exception">A delegate callback throws an exception.</exception>		
        [SuppressMessage("Microsoft.Reliability", "CA2000:Supprimer les objets avant la mise hors de portée")] 
        [SuppressMessage("Microsoft.Design", "CA1006:DoNotNestGenericTypesInMemberSignatures")]
		[SuppressMessage("Microsoft.Design", "CA1062:Valider les arguments de méthodes publiques", Justification = "Géré par Code Contract")]
        public static Func<Tuple<TResult, TimeSpan>> MeasureElapsed<TResult>(this Func<TResult> func)
        {
            Contract.Requires<ArgumentNullException>(func != null);
            Contract.Ensures(Contract.Result<Func<Tuple<TResult, TimeSpan>>>() != null);

            return () =>
            {
                TResult result = default(TResult);
                var sw = new Stopwatch();
                new UnitOfWork(sw.Stop).Do(x =>
                    {
                        sw.Start();
                        result = func();
                    });

                return Tuple.Create(result, sw.Elapsed);
            };
        }

		/// <summary>
        ///     Calcul du temps d'execution d'une méthode
        /// </summary>
        /// <typeparam name="T1">Type en entrée</typeparam>
        /// <typeparam name="TResult">Type en sortie</typeparam>
        /// <param name="func">Fonction évaluée</param>
        /// <returns>
        ///     Nouvelle fonction qui retourne un <see cref="Tuple{T1,T2}" />
        ///     qui contient la valeur de retour de la fonction et le temps d'execution
        /// </returns>
        /// <example>
        ///     calcul de factorielle avec memoization de la fonction et ajout d'un calcul de temps d'execution
        ///     <code>
        /// <![CDATA[
        ///    Func<int, int> factorial = null;
        ///    factorial = x => x.Match().With(i => i < 2, i => i).Else((i => i * factorial(i - 1))).Do();
        ///    var f = factorial.Memoize().Measure();
        /// ]]>
        /// </code>
        /// </example>
        /// <exception cref="Exception">A delegate callback throws an exception.</exception>		
        [SuppressMessage("Microsoft.Reliability", "CA2000:Supprimer les objets avant la mise hors de portée")] 
        [SuppressMessage("Microsoft.Design", "CA1006:DoNotNestGenericTypesInMemberSignatures")]
		[SuppressMessage("Microsoft.Design", "CA1062:Valider les arguments de méthodes publiques", Justification = "Géré par Code Contract")]
        public static Func<T1, Tuple<TResult, TimeSpan>> MeasureElapsed<T1, TResult>(this Func<T1, TResult> func)
        {
            Contract.Requires<ArgumentNullException>(func != null);
            Contract.Ensures(Contract.Result<Func<T1, Tuple<TResult, TimeSpan>>>() != null);

            return args =>
            {
                TResult result = default(TResult);
                var sw = new Stopwatch();
                new UnitOfWork(sw.Stop).Do(
                    x =>
                    {
                        sw.Start();
                        result = func(args);
                    });

                return Tuple.Create(result, sw.Elapsed);
            };
        }

	<# 
	for(var i = 2; i <= 10; i++)
	{ 
        var t = String.Join("", Enumerable.Range(1, i).Select(x => "T" + x + ", "));
        var xarg = String.Format("({0})", String.Join(", ", Enumerable.Range(1, i).Select(x => "x" + x)));
		var xarg2 = String.Join("", Enumerable.Range(1, i - 1).Select(x => String.Format("(x{0})", x)));
		var y = "x" + i;		
		var typeparams = String.Join(Environment.NewLine, Enumerable.Range(1, i).Select(x => String.Format("/// <typeparam name=\"T{0}\">The type of the {0}.</typeparam>", x)));
	#>
	    /// <summary>
        ///     Calcul du temps d'execution d'une méthode
        /// </summary>
		<#= typeparams #>
        /// <typeparam name="TResult">Type encapsuler par un <see cref="Either"/>.</typeparam>
        /// <param name="func">Fonction à décorer par un gestionnaire d'exception qui retourn un <see cref="Either{TValue}"/> dans tous les cas.</param>
        /// <returns>
        ///     Nouvelle fonction qui retourne un <see cref="Tuple{T1,T2}" />
        ///     qui contient la valeur de retour de la fonction et le temps d'execution
        /// </returns>
		[Obsolete("Ne plus utiliser",false)]
	    [SuppressMessage("Microsoft.Reliability", "CA2000:Supprimer les objets avant la mise hors de portée")] 
        [SuppressMessage("Microsoft.Design", "CA1006:DoNotNestGenericTypesInMemberSignatures")]
		[SuppressMessage("Microsoft.Design", "CA1062:Valider les arguments de méthodes publiques", Justification = "Géré par Code Contract")]
        public static Func<<#= t #>Tuple<TResult,long>> Measure<<#= t #>TResult>(this Func<<#= t #>TResult> func)
        {
			Contract.Requires<ArgumentNullException>(func != null);
            Contract.Ensures(Contract.Result<Func<<#= t #>Tuple<TResult, long>>>() != null);

            return <#= xarg #> => func.Currying()<#= xarg2 #>.Measure()(<#= y #>);
        }

		/// <summary>
        ///     Calcul du temps d'execution d'une méthode
        /// </summary>
		<#= typeparams #>
        /// <typeparam name="TResult">Type encapsuler par un <see cref="Either"/>.</typeparam>
        /// <param name="func">Fonction à décorer par un gestionnaire d'exception qui retourn un <see cref="Either{TValue}"/> dans tous les cas.</param>
        /// <returns>
        ///     Nouvelle fonction qui retourne un <see cref="Tuple{T1,T2}" />
        ///     qui contient la valeur de retour de la fonction et le temps d'execution
        /// </returns>		
	    [SuppressMessage("Microsoft.Reliability", "CA2000:Supprimer les objets avant la mise hors de portée")] 
        [SuppressMessage("Microsoft.Design", "CA1006:DoNotNestGenericTypesInMemberSignatures")]
		[SuppressMessage("Microsoft.Design", "CA1062:Valider les arguments de méthodes publiques", Justification = "Géré par Code Contract")]
        public static Func<<#= t #>Tuple<TResult,TimeSpan>> MeasureElapsed<<#= t #>TResult>(this Func<<#= t #>TResult> func)
        {
			Contract.Requires<ArgumentNullException>(func != null);
            Contract.Ensures(Contract.Result<Func<<#= t #>Tuple<TResult, TimeSpan>>>() != null);

            return <#= xarg #> => func.Currying()<#= xarg2 #>.MeasureElapsed()(<#= y #>);
        }

	<# } #>
}

}